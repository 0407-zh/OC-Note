## Heap & Stack

#### 在程序内存布局场景下，堆与栈表示的是两种内存管理方式

#### 数据结构场景下，堆与栈表示两种常用的数据结构

***

一、程序的内存分配方式不同

* Stack：**编译器自动分配释放**，存放函数的**参数值**、**局部变量的值**、**函数返回地址**等，其操作方法类似于数据结构的栈

* Heap：**一般由开发者释放**，若开发者不释放的话，程序结束时可能由操作系统回收，**值得注意的是它与数据结构的堆是两回事，分配方式类似于数据结构的链表**。

二、申请方式不同

* Stack：由系统**自动**分配

* Heap：需要开发者**手动**申请

三、申请后系统响应不同

* Stack：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。

* Heap：首先应该知道操作系统有一个**记录内存地址的链表，当系统收到程序的申请时，遍历该链表，寻找第一个空间大于所申请的空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序**。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的 delete 或 free 语句就能够正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会将多余的那部分重新放入空闲链表中。

四、申请的大小限制不同

* Stack：在 Windows 下，**栈是向低地址扩展的数据结构**，是一块**连续的**内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，**能从栈获得的空间较小**。

* Heap：**堆是向高地址扩展的数据结构**，是**不连续的**内存区域，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的有效虚拟内存空间，由此空间，**堆获得的空间比较灵活，也比较大**。

五、申请的效率不同

* Stack：由系统自动分配，**速度快**，但是**开发者无法控制**。

* Heap：由开发者自己分配，**速度较慢，容易产生碎片**，使用方便。

六、堆和栈的存储内容不同

* Stack：在函数调用时，**第一个进栈的是主函数中函数调用后的下一条指令的地址**，然后函数的各个参数，在大多数的 C 编译器中，参数是从右往左入栈的，当本次函数调用结束后，**局部变量先出栈**，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令。

* Heap：**一般是在堆的头部用一个字节存放堆的大小**，具体内容由开发者安排。

***

#### 数据结构中的堆和栈

* Stack：栈是一种运算受限的**线性表**，其限制是指只仅允许在表的一端进行插入和删除操作，这一端被称为栈顶（Top），相对地，把另一端称为栈底（Bottom）。把新元素放到栈顶元素的上面，使之成为新的栈顶元素称作进栈、入栈或压栈（Push）；把栈顶元素删除，使其相邻的元素成为新的栈顶元素称作出栈或退栈（Pop）。这种受限的运算使栈拥有“**先进后出**”的特性（First In Last Out），简称FILO。
* 栈分顺序栈和链式栈两种。**栈是一种线性结构**，所以可以使用数组或链表（单向链表、双向链表或循环链表）作为底层数据结构。使用数组实现的栈叫做顺序栈，使用链表实现的栈叫做链式栈，二者的区别是顺序栈中的元素地址连续，链式栈中的元素地址不连续。

* Heap：堆是一种常用的**树形结构，是一种特殊的完全二叉树**，当且仅当满足所有节点的值总是不大于或不小于其父节点的值的完全二叉树被称之为堆。堆的这一特性称之为堆序性。因此，在一个堆中，根节点是最大（或最小）节点。如果根节点最小，称之为小顶堆（或小根堆），如果根节点最大，称之为大顶堆（或大根堆）。堆的左右孩子没有大小的顺序。
